package engine;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;
import com.maxeler.maxcompiler.v2.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.Optimization;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.Bits;

class NBufReg extends KernelLib {

  // All sourceless streams
  DFEVar[] rdata;
  DFEVar[] stageDone;
  DFEVar[] wdata;
  DFEVar[] wen;
  DFEVar[] curBuf;
  DFEType type;

  DFEVar rst_en;

  private void common (DFEType ttype, String smname, int par, Bits rstVal, DFEVar rst_signal, int n) {

    int bits = MathUtils.bitsToAddress(n);

    type = ttype;
    rdata = new DFEVar[n];
    stageDone = new DFEVar[n];
    wdata = new DFEVar[n];
    wen = new DFEVar[n];
    curBuf = new DFEVar[n];
    DFEVar[] rMuxInputs = new DFEVar[n];
    DelayLib[] r = new DelayLib[n];

    rst_en = rst_signal;

    SMIO sm = addStateMachine(smname, new NBufStateMachine(this, n, bits));
    for (int i = 0; i < n; i++) {
      stageDone[i] = dfeBool().newInstance(this);
      wdata[i] = type.newInstance(this);
      wen[i] = dfeBool().newInstance(this);
      curBuf[i] = sm.getOutput("curBuf" + i);
      sm.connectInput("stageDone" + i, stageDone[i]);
      r[i] = new DelayLib(this, wen[i], wdata[i], rst_en, rstVal);
      rMuxInputs[i] = r[i].q[0];
    }

    // Kindly finish MUX-ing in one cycle
    optimization.pushPipeliningFactor(0);
    for (int i = 0; i < n; i++) {
      rdata[i] = control.mux(curBuf[i], rMuxInputs);
    }
    optimization.popPipeliningFactor();
  }

  NBufReg(KernelLib owner, DFEType type, String smname, int par, Bits rstVal, int n) {
    super(owner);
    common(type, smname, par, rstVal, dfeBool().newInstance(this), n);
  }

  DFEVar read(int port) {
    return rdata[port];
  }

  void write(DFEVar data, int port) {
    wdata[port] <== data;
    wen[port] <== constant.var(true);
    rst_en <== constant.var(false);
  }

  void write(DFEVar data, DFEVar en, int port) {
    wdata[port] <== data;
    wen[port] <== en;
    rst_en <== constant.var(false);
  }


  void write(DFEVar data, DFEVar en, DFEVar rst, int port) {
    wdata[port] <== data;
    wen[port] <== en;
    rst_en <== rst;
  }

  void connectDummyWr(DFEVar junk, int[] port) {
    for (int i = 0; i < port.length; i++) {
      wdata[port[i]] <== constant.var(type, 0);
      wen[port[i]] <== constant.var(false);
    }
  }
  void connectDummyDone(DFEVar junk, int[] port) {
    for (int i = 0; i < port.length; i++) {
      stageDone[port[i]] <== constant.var(false);
    }
  }


  void connectStagedone(DFEVar done, int[] port) {
    for (int i = 0; i < port.length; i++) {
      stageDone[port[i]] <== done;
    }
  }

}
