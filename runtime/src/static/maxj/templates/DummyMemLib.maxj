package engine;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;
import com.maxeler.maxcompiler.v2.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

/*
 * @DummyMemLib: Library that provides the same accessor methods as Block RAM
 * but is just a dummy register.
 */
class DummyMemLib extends KernelLib {

  DFEType type;
  int banks0;
  int banks1;
  DFEVector<DFEVar> stream;
  void common(DFEType type, int banks0, int banks1) {
    this.banks0 = banks0;
    this.banks1 = banks1;
    this.type = type;
    DFEVectorType<DFEVar> vecType = new DFEVectorType<DFEVar>(type, banks0*banks1);
    this.stream = vecType.newInstance(this);
  }

  DummyMemLib(KernelLib owner, DFEType type, int banks0) {
    super(owner);
    common(type, banks0, 1);
  }

  DummyMemLib(KernelLib owner, DFEType type, int banks0, int banks1) {
    super(owner);
    common(type, banks0, banks1);
  }

  DFEVar connectRport(DFEVar srcAddr) {
    return stream[0];
  }

  DFEVector<DFEVar> connectRport(DFEVector<DFEVar> srcAddr) {
    return stream;
  }

  DFEVector<DFEVar> connectRport(DFEVector<DFEVar> srcAddr, int touch) {
    DFEVectorType<DFEVar> vecType = new DFEVectorType<DFEVar>(type, banks0);
    DFEVector<DFEVar> p = vecType.newInstance(this);
    for (int i=0; i < banks0; i++) {
      p[i] <== stream[i + touch*banks0];
    }
    return p;
  }

  void connectWport(DFEVar dstAddr, DFEVar dstData, DFEVar en) {
    for (int i=0; i<banks0; i++) {
      stream[i] <== Reductions.streamHold(dstAddr.cast(type) ^ dstData.cast(type), en);
    }
  }

  void connectWport(DFEVector<DFEVar> dstAddr, DFEVector<DFEVar> dstData, DFEVar en) {
    for (int i=0; i<banks0; i++) {
      System.out.println("i = " + i);
      stream[i] <== Reductions.streamHold(dstAddr[i].cast(type) ^ dstData[i].cast(type), en);
    }
  }

  void connectWport(DFEVector<DFEVar> dstAddr, DFEVector<DFEVar> dstData, DFEVar en, int touch) {
    for (int i=0; i < banks0; i++) {
      System.out.println("i = " + i);
      stream[i + touch*banks0] <== Reductions.streamHold(dstAddr[i].cast(type) ^ dstData[i].cast(type), en);
    }
  }

  void connectWport(DFEVar dstAddr, DFEVar dstData, DFEVar en, int start, int stride) {
    for (int i=0; i<banks0; i++) {
      stream[i] <== Reductions.streamHold(dstAddr.cast(type) ^ dstData.cast(type), en);
    }
  }

  void connectWport(DFEVar dstAddr, DFEVar dstData) {
    stream[0] <== Reductions.streamHold(dstAddr.cast(type) ^ dstData.cast(type), constant.var(true));
  }

}
